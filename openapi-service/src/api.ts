/* tslint:disable */
/* eslint-disable */
/**
 * Gently OpenAPI
 * OpenAPI for interacting with our Gently inventory management system.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * The unique identifier for the attribute
     * @type {string}
     * @memberof Attribute
     */
    'attribute_id'?: string;
    /**
     * The name of the attribute
     * @type {string}
     * @memberof Attribute
     */
    'attribute_name'?: string;
    /**
     * The type of the attribute
     * @type {string}
     * @memberof Attribute
     */
    'attribute_type'?: AttributeAttributeTypeEnum;
    /**
     * The short code of the attribute, this can be used for HTTP query parameters to dynamically filter products by attribute, should be alphanumeric and unique
     * @type {string}
     * @memberof Attribute
     */
    'short_code'?: string;
    /**
     * Whether or not the attribute is required to be assigned to a product
     * @type {boolean}
     * @memberof Attribute
     */
    'is_required'?: boolean;
    /**
     * The date and time the attribute was created
     * @type {string}
     * @memberof Attribute
     */
    'created_at'?: string;
    /**
     * The unique ID of the user that created the attribute
     * @type {string}
     * @memberof Attribute
     */
    'created_by'?: string;
    /**
     * The date and time the attribute was last updated
     * @type {string}
     * @memberof Attribute
     */
    'updated_at'?: string;
    /**
     * The unique ID of the user that last updated the attribute
     * @type {string}
     * @memberof Attribute
     */
    'updated_by'?: string;
}

export const AttributeAttributeTypeEnum = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
    Datetime: 'datetime'
} as const;

export type AttributeAttributeTypeEnum = typeof AttributeAttributeTypeEnum[keyof typeof AttributeAttributeTypeEnum];

/**
 * 
 * @export
 * @interface AuthChangePasswordRequestBody
 */
export interface AuthChangePasswordRequestBody {
    /**
     * The email address of the user
     * @type {string}
     * @memberof AuthChangePasswordRequestBody
     */
    'email': string;
    /**
     * The user\'s current password
     * @type {string}
     * @memberof AuthChangePasswordRequestBody
     */
    'current_password': string;
    /**
     * The user\'s new password
     * @type {string}
     * @memberof AuthChangePasswordRequestBody
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordRequestBody
 */
export interface AuthForgotPasswordRequestBody {
    /**
     * The email address of the user requesting the password reset token.
     * @type {string}
     * @memberof AuthForgotPasswordRequestBody
     */
    'email': string;
}
/**
 * Request body for refreshing a token, to be used by all users
 * @export
 * @interface AuthRefreshTokenRequestBody
 */
export interface AuthRefreshTokenRequestBody {
    /**
     * The refresh token
     * @type {string}
     * @memberof AuthRefreshTokenRequestBody
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface AuthResendVerificationRequestBody
 */
export interface AuthResendVerificationRequestBody {
    /**
     * The email address of the user requesting the verification code.
     * @type {string}
     * @memberof AuthResendVerificationRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthResetPasswordBody
 */
export interface AuthResetPasswordBody {
    /**
     * The user\'s new password
     * @type {string}
     * @memberof AuthResetPasswordBody
     */
    'new_password': string;
    /**
     * The reset password token sent to the user\'s email
     * @type {string}
     * @memberof AuthResetPasswordBody
     */
    'token': string;
    /**
     * The email address of the user (optional if user_id is provided in the session)
     * @type {string}
     * @memberof AuthResetPasswordBody
     */
    'email'?: string;
}
/**
 * Request body for signing in a user, only to be used by admin users or operator users
 * @export
 * @interface AuthSignInRequestBody
 */
export interface AuthSignInRequestBody {
    /**
     * The user\'s email address
     * @type {string}
     * @memberof AuthSignInRequestBody
     */
    'email': string;
    /**
     * The user\'s password
     * @type {string}
     * @memberof AuthSignInRequestBody
     */
    'password': string;
}
/**
 * Request body for signing up a user, only to be used by admin users or operator users
 * @export
 * @interface AuthSignUpRequestBody
 */
export interface AuthSignUpRequestBody {
    /**
     * The user\'s email address
     * @type {string}
     * @memberof AuthSignUpRequestBody
     */
    'email': string;
    /**
     * The user\'s password
     * @type {string}
     * @memberof AuthSignUpRequestBody
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthTOTPSetupRequestBody
 */
export interface AuthTOTPSetupRequestBody {
    /**
     * Email address of the user for whom TOTP is being set up
     * @type {string}
     * @memberof AuthTOTPSetupRequestBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthTOTPVerifyRequestBody
 */
export interface AuthTOTPVerifyRequestBody {
    /**
     * Email address of the user verifying TOTP
     * @type {string}
     * @memberof AuthTOTPVerifyRequestBody
     */
    'email': string;
    /**
     * The TOTP token to verify
     * @type {string}
     * @memberof AuthTOTPVerifyRequestBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * The unique ID of the user
     * @type {string}
     * @memberof AuthUser
     */
    'user_id'?: string;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof AuthUser
     */
    'email'?: string;
    /**
     * The last time the user was active
     * @type {string}
     * @memberof AuthUser
     */
    'last_active_at'?: string | null;
    /**
     * JWT access token for user authentication
     * @type {string}
     * @memberof AuthUser
     */
    'access_token'?: string | null;
    /**
     * JWT refresh token for user session renewal
     * @type {string}
     * @memberof AuthUser
     */
    'refresh_token'?: string | null;
    /**
     * Indicates if the email is verified
     * @type {boolean}
     * @memberof AuthUser
     */
    'auth_email_verified'?: boolean | null;
    /**
     * Timestamp of the last TOTP verification
     * @type {string}
     * @memberof AuthUser
     */
    'auth_totp_verified_at'?: string | null;
    /**
     * Indicates if TOTP is enabled for the user
     * @type {boolean}
     * @memberof AuthUser
     */
    'auth_totp_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface AuthVerifyEmailRequestBody
 */
export interface AuthVerifyEmailRequestBody {
    /**
     * The admin or operator user\'s email address
     * @type {string}
     * @memberof AuthVerifyEmailRequestBody
     */
    'email': string;
    /**
     * TOTP verification code sent to the user\'s email
     * @type {string}
     * @memberof AuthVerifyEmailRequestBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateAttributeRequestBody
 */
export interface CreateAttributeRequestBody {
    /**
     * The name of the attribute
     * @type {string}
     * @memberof CreateAttributeRequestBody
     */
    'attribute_name': string;
    /**
     * The type of the attribute
     * @type {string}
     * @memberof CreateAttributeRequestBody
     */
    'attribute_type': CreateAttributeRequestBodyAttributeTypeEnum;
    /**
     * The short code of the attribute, this can be used for HTTP query parameters to dynamically filter products by attribute, should be alphanumeric and unique
     * @type {string}
     * @memberof CreateAttributeRequestBody
     */
    'short_code': string;
    /**
     * Whether or not the attribute is required to be assigned to a product
     * @type {boolean}
     * @memberof CreateAttributeRequestBody
     */
    'is_required': boolean;
}

export const CreateAttributeRequestBodyAttributeTypeEnum = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
    Datetime: 'datetime'
} as const;

export type CreateAttributeRequestBodyAttributeTypeEnum = typeof CreateAttributeRequestBodyAttributeTypeEnum[keyof typeof CreateAttributeRequestBodyAttributeTypeEnum];

/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * The name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'product_name': string;
    /**
     * The description of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'description': string;
    /**
     * The attributes of the product
     * @type {Array<CreateProductRequestAttributesInner>}
     * @memberof CreateProductRequest
     */
    'attributes'?: Array<CreateProductRequestAttributesInner>;
}
/**
 * 
 * @export
 * @interface CreateProductRequestAttributesInner
 */
export interface CreateProductRequestAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestAttributesInner
     */
    'attribute_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestAttributesInner
     */
    'attribute_value'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword200Response
 */
export interface ForgotPassword200Response {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetAttributesResponse
 */
export interface GetAttributesResponse {
    /**
     * The attributes
     * @type {Array<Attribute>}
     * @memberof GetAttributesResponse
     */
    'items': Array<Attribute>;
    /**
     * The total number of attributes
     * @type {number}
     * @memberof GetAttributesResponse
     */
    'count': number;
    /**
     * The page size limit of the attributes
     * @type {number}
     * @memberof GetAttributesResponse
     */
    'limit': number;
    /**
     * The offset of the database cursor when fetching paginated attributes
     * @type {number}
     * @memberof GetAttributesResponse
     */
    'offset': number;
}
/**
 * 
 * @export
 * @interface GetProductsResponse
 */
export interface GetProductsResponse {
    /**
     * The products
     * @type {Array<Product>}
     * @memberof GetProductsResponse
     */
    'items': Array<Product>;
    /**
     * The total number of products
     * @type {number}
     * @memberof GetProductsResponse
     */
    'count': number;
    /**
     * The page size limit of the products
     * @type {number}
     * @memberof GetProductsResponse
     */
    'limit': number;
    /**
     * The offset of the database cursor when fetching paginated products
     * @type {number}
     * @memberof GetProductsResponse
     */
    'offset': number;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The unique identifier for the product
     * @type {string}
     * @memberof Product
     */
    'product_id'?: string;
    /**
     * The name of the product
     * @type {string}
     * @memberof Product
     */
    'product_name'?: string;
    /**
     * The description of the product
     * @type {string}
     * @memberof Product
     */
    'product_description'?: string;
    /**
     * The attributes of the product
     * @type {Array<CreateProductRequestAttributesInner>}
     * @memberof Product
     */
    'attributes'?: Array<CreateProductRequestAttributesInner>;
    /**
     * The date and time the product was created
     * @type {string}
     * @memberof Product
     */
    'created_at'?: string;
    /**
     * The unique ID of the user that created the product
     * @type {string}
     * @memberof Product
     */
    'created_by'?: string;
    /**
     * The date and time the product was last updated
     * @type {string}
     * @memberof Product
     */
    'updated_at'?: string;
    /**
     * The unique ID of the user that last updated the product
     * @type {string}
     * @memberof Product
     */
    'updated_by'?: string;
}
/**
 * 
 * @export
 * @interface RefreshToken200Response
 */
export interface RefreshToken200Response {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken200Response
     */
    'access_token'?: string;
}
/**
 * 
 * @export
 * @interface ResendVerification201Response
 */
export interface ResendVerification201Response {
    /**
     * 
     * @type {string}
     * @memberof ResendVerification201Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ResetPassword200Response
 */
export interface ResetPassword200Response {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SignIn200Response
 */
export interface SignIn200Response {
    /**
     * 
     * @type {string}
     * @memberof SignIn200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AuthUser}
     * @memberof SignIn200Response
     */
    'user'?: AuthUser;
}
/**
 * 
 * @export
 * @interface SignUp201Response
 */
export interface SignUp201Response {
    /**
     * 
     * @type {string}
     * @memberof SignUp201Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SignUp400Response
 */
export interface SignUp400Response {
    /**
     * 
     * @type {string}
     * @memberof SignUp400Response
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface TotpSetup200Response
 */
export interface TotpSetup200Response {
    /**
     * URL for configuring TOTP in a compatible app
     * @type {string}
     * @memberof TotpSetup200Response
     */
    'otpauth_url'?: string;
}
/**
 * 
 * @export
 * @interface TotpVerify200Response
 */
export interface TotpVerify200Response {
    /**
     * 
     * @type {string}
     * @memberof TotpVerify200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AuthUser}
     * @memberof TotpVerify200Response
     */
    'user'?: AuthUser;
}
/**
 * 
 * @export
 * @interface UpdateAttributeRequestBody
 */
export interface UpdateAttributeRequestBody {
    /**
     * The name of the attribute
     * @type {string}
     * @memberof UpdateAttributeRequestBody
     */
    'attribute_name'?: string;
    /**
     * Whether or not the attribute is required to be assigned to a product
     * @type {boolean}
     * @memberof UpdateAttributeRequestBody
     */
    'is_required'?: boolean;
    /**
     * The short code of the attribute, this can be used for HTTP query parameters to dynamically filter products by attribute, should be alphanumeric and unique
     * @type {string}
     * @memberof UpdateAttributeRequestBody
     */
    'short_code'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProductRequestBody
 */
export interface UpdateProductRequestBody {
    /**
     * The name of the product
     * @type {string}
     * @memberof UpdateProductRequestBody
     */
    'product_name'?: string;
    /**
     * The description of the product
     * @type {string}
     * @memberof UpdateProductRequestBody
     */
    'product_description'?: string | null;
    /**
     * The attributes of the product
     * @type {Array<CreateProductRequestAttributesInner>}
     * @memberof UpdateProductRequestBody
     */
    'attributes'?: Array<CreateProductRequestAttributesInner>;
}
/**
 * 
 * @export
 * @interface VerifyEmail200Response
 */
export interface VerifyEmail200Response {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AuthUser}
     * @memberof VerifyEmail200Response
     */
    'user'?: AuthUser;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes a user\'s password by verifying the current password.
         * @summary Change user password
         * @param {AuthChangePasswordRequestBody} authChangePasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (authChangePasswordRequestBody: AuthChangePasswordRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authChangePasswordRequestBody' is not null or undefined
            assertParamExists('changePassword', 'authChangePasswordRequestBody', authChangePasswordRequestBody)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authChangePasswordRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new attribute in the system.
         * @summary Create a new attribute
         * @param {CreateAttributeRequestBody} createAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute: async (createAttributeRequestBody: CreateAttributeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAttributeRequestBody' is not null or undefined
            assertParamExists('createAttribute', 'createAttributeRequestBody', createAttributeRequestBody)
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttributeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new product in the system.
         * @summary Create a new product
         * @param {CreateProductRequest} createProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (createProductRequest: CreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductRequest' is not null or undefined
            assertParamExists('createProduct', 'createProductRequest', createProductRequest)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an attribute in the system, including any applications of the attribute to products. The products themselves are not deleted, but the attribute is no longer associated with them.
         * @summary Delete an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute: async (attributeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteAttribute', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attribute_id}`
                .replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a password reset token to the user\'s email if the email is registered.
         * @summary Request password reset token
         * @param {AuthForgotPasswordRequestBody} authForgotPasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (authForgotPasswordRequestBody: AuthForgotPasswordRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordRequestBody' is not null or undefined
            assertParamExists('forgotPassword', 'authForgotPasswordRequestBody', authForgotPasswordRequestBody)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all attributes in the system. Note, the number of attributes is limited to 100, so pagination fields are present in the API but not supported in the UI at this time.
         * @summary Get all attributes
         * @param {number} [offset] The offset of the database cursor when fetching paginated attributes
         * @param {number} [limit] The number of items to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a product in the system.
         * @summary Get a product
         * @param {string} productId The unique identifier for the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProduct', 'productId', productId)
            const localVarPath = `/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all products in the system.
         * @summary Get all products
         * @param {number} [offset] The offset / cursor location to retrieve products from
         * @param {number} [limit] The number of items to retrieve
         * @param {string} [params] Dynamically templated parameters based on attribute codes to filter products by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (offset?: number, limit?: number, params?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a TOTP token for a standard user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify a user authentication request
         * @param {AuthRefreshTokenRequestBody} authRefreshTokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (authRefreshTokenRequestBody: AuthRefreshTokenRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRefreshTokenRequestBody' is not null or undefined
            assertParamExists('refreshToken', 'authRefreshTokenRequestBody', authRefreshTokenRequestBody)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRefreshTokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a TOTP email verification code to the specified user email, if the user exists and has not verified their email.
         * @summary Resend email verification code
         * @param {AuthResendVerificationRequestBody} authResendVerificationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerification: async (authResendVerificationRequestBody: AuthResendVerificationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResendVerificationRequestBody' is not null or undefined
            assertParamExists('resendVerification', 'authResendVerificationRequestBody', authResendVerificationRequestBody)
            const localVarPath = `/auth/resend-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResendVerificationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a user\'s password using a provided token and new password.
         * @summary Reset user password
         * @param {AuthResetPasswordBody} authResetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (authResetPasswordBody: AuthResetPasswordBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetPasswordBody' is not null or undefined
            assertParamExists('resetPassword', 'authResetPasswordBody', authResetPasswordBody)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates a user and provides access and refresh tokens if successful.
         * @summary Sign in a user
         * @param {AuthSignInRequestBody} authSignInRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (authSignInRequestBody: AuthSignInRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSignInRequestBody' is not null or undefined
            assertParamExists('signIn', 'authSignInRequestBody', authSignInRequestBody)
            const localVarPath = `/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSignInRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account and sends an email verification code.
         * @summary Sign up a new user
         * @param {AuthSignUpRequestBody} authSignUpRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (authSignUpRequestBody: AuthSignUpRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSignUpRequestBody' is not null or undefined
            assertParamExists('signUp', 'authSignUpRequestBody', authSignUpRequestBody)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSignUpRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a TOTP secret and returns the otpauth URL for configuring TOTP on a user account.
         * @summary Setup TOTP for user
         * @param {AuthTOTPSetupRequestBody} authTOTPSetupRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpSetup: async (authTOTPSetupRequestBody: AuthTOTPSetupRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authTOTPSetupRequestBody' is not null or undefined
            assertParamExists('totpSetup', 'authTOTPSetupRequestBody', authTOTPSetupRequestBody)
            const localVarPath = `/auth/totp/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authTOTPSetupRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a TOTP token for a user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify TOTP for user
         * @param {AuthTOTPVerifyRequestBody} authTOTPVerifyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpVerify: async (authTOTPVerifyRequestBody: AuthTOTPVerifyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authTOTPVerifyRequestBody' is not null or undefined
            assertParamExists('totpVerify', 'authTOTPVerifyRequestBody', authTOTPVerifyRequestBody)
            const localVarPath = `/auth/totp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authTOTPVerifyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an attribute in the system. Note that the attribute type cannot be changed.
         * @summary Update an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {UpdateAttributeRequestBody} updateAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute: async (attributeId: string, updateAttributeRequestBody: UpdateAttributeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('updateAttribute', 'attributeId', attributeId)
            // verify required parameter 'updateAttributeRequestBody' is not null or undefined
            assertParamExists('updateAttribute', 'updateAttributeRequestBody', updateAttributeRequestBody)
            const localVarPath = `/attributes/{attribute_id}`
                .replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAttributeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product in the system.
         * @summary Update a product
         * @param {string} productId The unique identifier for the product
         * @param {UpdateProductRequestBody} updateProductRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (productId: string, updateProductRequestBody: UpdateProductRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateProduct', 'productId', productId)
            // verify required parameter 'updateProductRequestBody' is not null or undefined
            assertParamExists('updateProduct', 'updateProductRequestBody', updateProductRequestBody)
            const localVarPath = `/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a user\'s email address with a TOTP verification code, updating the email verification status.
         * @summary Verify user email
         * @param {AuthVerifyEmailRequestBody} authVerifyEmailRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (authVerifyEmailRequestBody: AuthVerifyEmailRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyEmailRequestBody' is not null or undefined
            assertParamExists('verifyEmail', 'authVerifyEmailRequestBody', authVerifyEmailRequestBody)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyEmailRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes a user\'s password by verifying the current password.
         * @summary Change user password
         * @param {AuthChangePasswordRequestBody} authChangePasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(authChangePasswordRequestBody: AuthChangePasswordRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(authChangePasswordRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new attribute in the system.
         * @summary Create a new attribute
         * @param {CreateAttributeRequestBody} createAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttribute(createAttributeRequestBody: CreateAttributeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttribute(createAttributeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new product in the system.
         * @summary Create a new product
         * @param {CreateProductRequest} createProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(createProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an attribute in the system, including any applications of the attribute to products. The products themselves are not deleted, but the attribute is no longer associated with them.
         * @summary Delete an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttribute(attributeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttribute(attributeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a password reset token to the user\'s email if the email is registered.
         * @summary Request password reset token
         * @param {AuthForgotPasswordRequestBody} authForgotPasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(authForgotPasswordRequestBody: AuthForgotPasswordRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgotPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(authForgotPasswordRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all attributes in the system. Note, the number of attributes is limited to 100, so pagination fields are present in the API but not supported in the UI at this time.
         * @summary Get all attributes
         * @param {number} [offset] The offset of the database cursor when fetching paginated attributes
         * @param {number} [limit] The number of items to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributes(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAttributesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttributes(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a product in the system.
         * @summary Get a product
         * @param {string} productId The unique identifier for the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all products in the system.
         * @summary Get all products
         * @param {number} [offset] The offset / cursor location to retrieve products from
         * @param {number} [limit] The number of items to retrieve
         * @param {string} [params] Dynamically templated parameters based on attribute codes to filter products by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(offset?: number, limit?: number, params?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(offset, limit, params, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies a TOTP token for a standard user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify a user authentication request
         * @param {AuthRefreshTokenRequestBody} authRefreshTokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(authRefreshTokenRequestBody: AuthRefreshTokenRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(authRefreshTokenRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a TOTP email verification code to the specified user email, if the user exists and has not verified their email.
         * @summary Resend email verification code
         * @param {AuthResendVerificationRequestBody} authResendVerificationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerification(authResendVerificationRequestBody: AuthResendVerificationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResendVerification201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerification(authResendVerificationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets a user\'s password using a provided token and new password.
         * @summary Reset user password
         * @param {AuthResetPasswordBody} authResetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(authResetPasswordBody: AuthResetPasswordBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(authResetPasswordBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticates a user and provides access and refresh tokens if successful.
         * @summary Sign in a user
         * @param {AuthSignInRequestBody} authSignInRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(authSignInRequestBody: AuthSignInRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignIn200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(authSignInRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account and sends an email verification code.
         * @summary Sign up a new user
         * @param {AuthSignUpRequestBody} authSignUpRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(authSignUpRequestBody: AuthSignUpRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUp201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(authSignUpRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a TOTP secret and returns the otpauth URL for configuring TOTP on a user account.
         * @summary Setup TOTP for user
         * @param {AuthTOTPSetupRequestBody} authTOTPSetupRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totpSetup(authTOTPSetupRequestBody: AuthTOTPSetupRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotpSetup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totpSetup(authTOTPSetupRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.totpSetup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies a TOTP token for a user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify TOTP for user
         * @param {AuthTOTPVerifyRequestBody} authTOTPVerifyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totpVerify(authTOTPVerifyRequestBody: AuthTOTPVerifyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotpVerify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totpVerify(authTOTPVerifyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.totpVerify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an attribute in the system. Note that the attribute type cannot be changed.
         * @summary Update an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {UpdateAttributeRequestBody} updateAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttribute(attributeId: string, updateAttributeRequestBody: UpdateAttributeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttribute(attributeId, updateAttributeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateAttribute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a product in the system.
         * @summary Update a product
         * @param {string} productId The unique identifier for the product
         * @param {UpdateProductRequestBody} updateProductRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(productId: string, updateProductRequestBody: UpdateProductRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(productId, updateProductRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies a user\'s email address with a TOTP verification code, updating the email verification status.
         * @summary Verify user email
         * @param {AuthVerifyEmailRequestBody} authVerifyEmailRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(authVerifyEmailRequestBody: AuthVerifyEmailRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyEmail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(authVerifyEmailRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Changes a user\'s password by verifying the current password.
         * @summary Change user password
         * @param {AuthChangePasswordRequestBody} authChangePasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(authChangePasswordRequestBody: AuthChangePasswordRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<ResetPassword200Response> {
            return localVarFp.changePassword(authChangePasswordRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new attribute in the system.
         * @summary Create a new attribute
         * @param {CreateAttributeRequestBody} createAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute(createAttributeRequestBody: CreateAttributeRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<Attribute> {
            return localVarFp.createAttribute(createAttributeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new product in the system.
         * @summary Create a new product
         * @param {CreateProductRequest} createProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.createProduct(createProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an attribute in the system, including any applications of the attribute to products. The products themselves are not deleted, but the attribute is no longer associated with them.
         * @summary Delete an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute(attributeId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAttribute(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a password reset token to the user\'s email if the email is registered.
         * @summary Request password reset token
         * @param {AuthForgotPasswordRequestBody} authForgotPasswordRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(authForgotPasswordRequestBody: AuthForgotPasswordRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<ForgotPassword200Response> {
            return localVarFp.forgotPassword(authForgotPasswordRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all attributes in the system. Note, the number of attributes is limited to 100, so pagination fields are present in the API but not supported in the UI at this time.
         * @summary Get all attributes
         * @param {number} [offset] The offset of the database cursor when fetching paginated attributes
         * @param {number} [limit] The number of items to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetAttributesResponse> {
            return localVarFp.getAttributes(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a product in the system.
         * @summary Get a product
         * @param {string} productId The unique identifier for the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.getProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all products in the system.
         * @summary Get all products
         * @param {number} [offset] The offset / cursor location to retrieve products from
         * @param {number} [limit] The number of items to retrieve
         * @param {string} [params] Dynamically templated parameters based on attribute codes to filter products by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(offset?: number, limit?: number, params?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetProductsResponse> {
            return localVarFp.getProducts(offset, limit, params, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a TOTP token for a standard user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify a user authentication request
         * @param {AuthRefreshTokenRequestBody} authRefreshTokenRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(authRefreshTokenRequestBody: AuthRefreshTokenRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<RefreshToken200Response> {
            return localVarFp.refreshToken(authRefreshTokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a TOTP email verification code to the specified user email, if the user exists and has not verified their email.
         * @summary Resend email verification code
         * @param {AuthResendVerificationRequestBody} authResendVerificationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerification(authResendVerificationRequestBody: AuthResendVerificationRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<ResendVerification201Response> {
            return localVarFp.resendVerification(authResendVerificationRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets a user\'s password using a provided token and new password.
         * @summary Reset user password
         * @param {AuthResetPasswordBody} authResetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(authResetPasswordBody: AuthResetPasswordBody, options?: RawAxiosRequestConfig): AxiosPromise<ResetPassword200Response> {
            return localVarFp.resetPassword(authResetPasswordBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates a user and provides access and refresh tokens if successful.
         * @summary Sign in a user
         * @param {AuthSignInRequestBody} authSignInRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(authSignInRequestBody: AuthSignInRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<SignIn200Response> {
            return localVarFp.signIn(authSignInRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account and sends an email verification code.
         * @summary Sign up a new user
         * @param {AuthSignUpRequestBody} authSignUpRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(authSignUpRequestBody: AuthSignUpRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<SignUp201Response> {
            return localVarFp.signUp(authSignUpRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a TOTP secret and returns the otpauth URL for configuring TOTP on a user account.
         * @summary Setup TOTP for user
         * @param {AuthTOTPSetupRequestBody} authTOTPSetupRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpSetup(authTOTPSetupRequestBody: AuthTOTPSetupRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<TotpSetup200Response> {
            return localVarFp.totpSetup(authTOTPSetupRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a TOTP token for a user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
         * @summary Verify TOTP for user
         * @param {AuthTOTPVerifyRequestBody} authTOTPVerifyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpVerify(authTOTPVerifyRequestBody: AuthTOTPVerifyRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<TotpVerify200Response> {
            return localVarFp.totpVerify(authTOTPVerifyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an attribute in the system. Note that the attribute type cannot be changed.
         * @summary Update an attribute
         * @param {string} attributeId The unique identifier for the attribute
         * @param {UpdateAttributeRequestBody} updateAttributeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute(attributeId: string, updateAttributeRequestBody: UpdateAttributeRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<Attribute> {
            return localVarFp.updateAttribute(attributeId, updateAttributeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product in the system.
         * @summary Update a product
         * @param {string} productId The unique identifier for the product
         * @param {UpdateProductRequestBody} updateProductRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, updateProductRequestBody: UpdateProductRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.updateProduct(productId, updateProductRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a user\'s email address with a TOTP verification code, updating the email verification status.
         * @summary Verify user email
         * @param {AuthVerifyEmailRequestBody} authVerifyEmailRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(authVerifyEmailRequestBody: AuthVerifyEmailRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<VerifyEmail200Response> {
            return localVarFp.verifyEmail(authVerifyEmailRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Changes a user\'s password by verifying the current password.
     * @summary Change user password
     * @param {AuthChangePasswordRequestBody} authChangePasswordRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changePassword(authChangePasswordRequestBody: AuthChangePasswordRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changePassword(authChangePasswordRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new attribute in the system.
     * @summary Create a new attribute
     * @param {CreateAttributeRequestBody} createAttributeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAttribute(createAttributeRequestBody: CreateAttributeRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttribute(createAttributeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new product in the system.
     * @summary Create a new product
     * @param {CreateProductRequest} createProductRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProduct(createProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an attribute in the system, including any applications of the attribute to products. The products themselves are not deleted, but the attribute is no longer associated with them.
     * @summary Delete an attribute
     * @param {string} attributeId The unique identifier for the attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAttribute(attributeId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttribute(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a password reset token to the user\'s email if the email is registered.
     * @summary Request password reset token
     * @param {AuthForgotPasswordRequestBody} authForgotPasswordRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forgotPassword(authForgotPasswordRequestBody: AuthForgotPasswordRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(authForgotPasswordRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all attributes in the system. Note, the number of attributes is limited to 100, so pagination fields are present in the API but not supported in the UI at this time.
     * @summary Get all attributes
     * @param {number} [offset] The offset of the database cursor when fetching paginated attributes
     * @param {number} [limit] The number of items to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAttributes(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAttributes(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a product in the system.
     * @summary Get a product
     * @param {string} productId The unique identifier for the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProduct(productId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all products in the system.
     * @summary Get all products
     * @param {number} [offset] The offset / cursor location to retrieve products from
     * @param {number} [limit] The number of items to retrieve
     * @param {string} [params] Dynamically templated parameters based on attribute codes to filter products by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProducts(offset?: number, limit?: number, params?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProducts(offset, limit, params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies a TOTP token for a standard user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
     * @summary Verify a user authentication request
     * @param {AuthRefreshTokenRequestBody} authRefreshTokenRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshToken(authRefreshTokenRequestBody: AuthRefreshTokenRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(authRefreshTokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a TOTP email verification code to the specified user email, if the user exists and has not verified their email.
     * @summary Resend email verification code
     * @param {AuthResendVerificationRequestBody} authResendVerificationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resendVerification(authResendVerificationRequestBody: AuthResendVerificationRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendVerification(authResendVerificationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets a user\'s password using a provided token and new password.
     * @summary Reset user password
     * @param {AuthResetPasswordBody} authResetPasswordBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPassword(authResetPasswordBody: AuthResetPasswordBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(authResetPasswordBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates a user and provides access and refresh tokens if successful.
     * @summary Sign in a user
     * @param {AuthSignInRequestBody} authSignInRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signIn(authSignInRequestBody: AuthSignInRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signIn(authSignInRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account and sends an email verification code.
     * @summary Sign up a new user
     * @param {AuthSignUpRequestBody} authSignUpRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signUp(authSignUpRequestBody: AuthSignUpRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signUp(authSignUpRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a TOTP secret and returns the otpauth URL for configuring TOTP on a user account.
     * @summary Setup TOTP for user
     * @param {AuthTOTPSetupRequestBody} authTOTPSetupRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public totpSetup(authTOTPSetupRequestBody: AuthTOTPSetupRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).totpSetup(authTOTPSetupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies a TOTP token for a user. If the token is valid, enables TOTP for the user and issues new access and refresh tokens.
     * @summary Verify TOTP for user
     * @param {AuthTOTPVerifyRequestBody} authTOTPVerifyRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public totpVerify(authTOTPVerifyRequestBody: AuthTOTPVerifyRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).totpVerify(authTOTPVerifyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an attribute in the system. Note that the attribute type cannot be changed.
     * @summary Update an attribute
     * @param {string} attributeId The unique identifier for the attribute
     * @param {UpdateAttributeRequestBody} updateAttributeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAttribute(attributeId: string, updateAttributeRequestBody: UpdateAttributeRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAttribute(attributeId, updateAttributeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a product in the system.
     * @summary Update a product
     * @param {string} productId The unique identifier for the product
     * @param {UpdateProductRequestBody} updateProductRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProduct(productId: string, updateProductRequestBody: UpdateProductRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProduct(productId, updateProductRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies a user\'s email address with a TOTP verification code, updating the email verification status.
     * @summary Verify user email
     * @param {AuthVerifyEmailRequestBody} authVerifyEmailRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyEmail(authVerifyEmailRequestBody: AuthVerifyEmailRequestBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifyEmail(authVerifyEmailRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



